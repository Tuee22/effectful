"""Type stubs for redis.asyncio.client."""

from typing import (
    AsyncIterator,
    Awaitable,
    Generic,
    Optional,
    TypeVar,
    Union,
)

_T = TypeVar("_T", bound=Union[bytes, str])


class PubSub:
    """Redis pub/sub client."""

    async def subscribe(self, *args: str, **kwargs: object) -> None: ...
    async def unsubscribe(self, *args: str) -> None: ...
    async def psubscribe(self, *args: str, **kwargs: object) -> None: ...
    async def punsubscribe(self, *args: str) -> None: ...
    def listen(self) -> AsyncIterator[dict[str, object]]: ...
    async def get_message(
        self, ignore_subscribe_messages: bool = False, timeout: float = 0.0
    ) -> Optional[dict[str, object]]: ...
    async def close(self) -> None: ...
    async def reset(self) -> None: ...


class ConnectionPool:
    """Redis connection pool."""

    def __init__(
        self,
        connection_class: Optional[type] = None,
        max_connections: Optional[int] = None,
        **kwargs: object,
    ) -> None: ...
    async def disconnect(self, inuse_connections: bool = True) -> None: ...
    async def get_connection(
        self, command_name: str, *keys: object, **options: object
    ) -> object: ...
    def release(self, connection: object) -> None: ...


class Redis(Generic[_T]):
    """Async Redis client."""

    @classmethod
    async def from_url(
        cls,
        url: str,
        **kwargs: object,
    ) -> "Redis[_T]": ...

    def __init__(
        self,
        host: str = "localhost",
        port: int = 6379,
        db: int = 0,
        password: Optional[str] = None,
        socket_timeout: Optional[float] = None,
        socket_connect_timeout: Optional[float] = None,
        socket_keepalive: Optional[bool] = None,
        socket_keepalive_options: Optional[dict[str, int]] = None,
        connection_pool: Optional[ConnectionPool] = None,
        unix_socket_path: Optional[str] = None,
        encoding: str = "utf-8",
        encoding_errors: str = "strict",
        decode_responses: bool = False,
        retry_on_timeout: bool = False,
        ssl: bool = False,
        ssl_keyfile: Optional[str] = None,
        ssl_certfile: Optional[str] = None,
        ssl_cert_reqs: str = "required",
        ssl_ca_certs: Optional[str] = None,
        ssl_check_hostname: bool = False,
        max_connections: Optional[int] = None,
        single_connection_client: bool = False,
        health_check_interval: int = 0,
        client_name: Optional[str] = None,
        username: Optional[str] = None,
        **kwargs: object,
    ) -> None: ...

    # Connection management
    async def close(self) -> None: ...
    async def aclose(self) -> None: ...
    async def __aenter__(self) -> "Redis": ...
    async def __aexit__(
        self, exc_type: object, exc_val: object, exc_tb: object
    ) -> None: ...

    # Pub/Sub
    def pubsub(self, **kwargs: object) -> PubSub: ...
    async def publish(self, channel: str, message: Union[str, bytes]) -> int: ...

    # String operations
    async def get(self, name: str) -> Optional[Union[str, bytes]]: ...
    async def set(
        self,
        name: str,
        value: Union[str, bytes, int, float],
        ex: Optional[int] = None,
        px: Optional[int] = None,
        nx: bool = False,
        xx: bool = False,
        keepttl: bool = False,
        get: bool = False,
        exat: Optional[int] = None,
        pxat: Optional[int] = None,
    ) -> Optional[bool]: ...
    async def setex(
        self, name: str, time: int, value: Union[str, bytes, int, float]
    ) -> bool: ...
    async def setnx(
        self, name: str, value: Union[str, bytes, int, float]
    ) -> bool: ...
    async def getdel(self, name: str) -> Optional[Union[str, bytes]]: ...
    async def delete(self, *names: str) -> int: ...
    async def exists(self, *names: str) -> int: ...
    async def expire(self, name: str, time: int) -> bool: ...
    async def ttl(self, name: str) -> int: ...
    async def incr(self, name: str, amount: int = 1) -> int: ...
    async def decr(self, name: str, amount: int = 1) -> int: ...

    # Set operations
    def sadd(
        self, name: str, *values: Union[str, bytes]
    ) -> Union[Awaitable[int], int]: ...
    def srem(
        self, name: str, *values: Union[str, bytes]
    ) -> Union[Awaitable[int], int]: ...
    def smembers(self, name: str) -> Union[Awaitable[set[object]], set[object]]: ...
    async def sismember(self, name: str, value: Union[str, bytes]) -> bool: ...
    async def scard(self, name: str) -> int: ...

    # Hash operations
    async def hget(self, name: str, key: str) -> Optional[Union[str, bytes]]: ...
    async def hset(
        self,
        name: str,
        key: Optional[str] = None,
        value: Optional[Union[str, bytes, int, float]] = None,
        mapping: Optional[dict[str, Union[str, bytes, int, float]]] = None,
    ) -> int: ...
    async def hdel(self, name: str, *keys: str) -> int: ...
    async def hgetall(self, name: str) -> dict[Union[str, bytes], Union[str, bytes]]: ...
    async def hexists(self, name: str, key: str) -> bool: ...

    # List operations
    async def lpush(self, name: str, *values: Union[str, bytes]) -> int: ...
    async def rpush(self, name: str, *values: Union[str, bytes]) -> int: ...
    async def lpop(
        self, name: str, count: Optional[int] = None
    ) -> Optional[Union[str, bytes, list[Union[str, bytes]]]]: ...
    async def rpop(
        self, name: str, count: Optional[int] = None
    ) -> Optional[Union[str, bytes, list[Union[str, bytes]]]]: ...
    async def lrange(self, name: str, start: int, end: int) -> list[Union[str, bytes]]: ...
    async def llen(self, name: str) -> int: ...

    # Key operations
    async def keys(self, pattern: str = "*") -> list[Union[str, bytes]]: ...
    async def scan(
        self,
        cursor: int = 0,
        match: Optional[str] = None,
        count: Optional[int] = None,
        type: Optional[str] = None,
    ) -> tuple[int, list[Union[str, bytes]]]: ...
    async def type(self, name: str) -> str: ...

    # Server operations
    async def ping(self) -> bool: ...
    async def info(self, section: Optional[str] = None) -> dict[str, object]: ...
    async def dbsize(self) -> int: ...
    async def flushdb(self, asynchronous: bool = False) -> bool: ...


class Pipeline:
    """Redis pipeline for batching commands."""

    async def execute(self, raise_on_error: bool = True) -> list[object]: ...
    async def __aenter__(self) -> "Pipeline": ...
    async def __aexit__(self, exc_type: object, exc_val: object, exc_tb: object) -> None: ...

    # Chainable methods (return self for chaining)
    def get(self, name: str) -> "Pipeline": ...
    def set(self, name: str, value: Union[str, bytes, int, float], **kwargs: object) -> "Pipeline": ...
    def delete(self, *names: str) -> "Pipeline": ...
    def expire(self, name: str, time: int) -> "Pipeline": ...
    def sadd(self, name: str, *values: Union[str, bytes]) -> "Pipeline": ...
    def srem(self, name: str, *values: Union[str, bytes]) -> "Pipeline": ...
