globals:
  policies:
    - "All development commands run via Docker: `docker compose -f docker/docker-compose.yml exec effectful poetry run <command>`"
    - "Zero escape hatches: forbid Any, cast(), and `# type: ignore` anywhere (code, tests, docs)."
    - "Favor immutable design: frozen dataclasses, pure programs, effects-as-data, exhaustive pattern matching, Result-based errors."
    - "No git commits/pushes by agents; leave changes uncommitted."
    - "Respect SSoT ordering: document SSoT statements override others; README navigation breaks ties."
  quality_gates:
    - "Run `check-code` (Black + mypy strict) before tests."
    - "Run pytest inside Docker; no skipped tests; coverage threshold ≥ 45% (adapters excluded)."
  command_prefix: "docker compose -f docker/docker-compose.yml exec effectful poetry run"

agents:
  - name: architecture
    source: documents/engineering/architecture.md
    intent: Enforce 5-layer flow (Application → Runner → Composite → Specialized Interpreters → Infra) with effects as pure data and fail-fast Result propagation.
    enforce:
      - Programs yield effects only; no direct infra calls.
      - Composite routes every effect in AllEffects; keep AllEffects/EffectResult unions updated.
      - Interpreters return Ok/Err and remain fail-fast; immutable dataclasses.
      - Planned features (parallel, retries, timeouts, logging) not assumed delivered.
    suggest:
      - Add interpreter per new effect type and register in Composite.
      - Use exhaustive match on Result at boundaries; propagate errors immediately.

  - name: code_quality
    source: documents/engineering/code_quality.md
    intent: Uphold zero-tolerance type safety and purity across programs, interpreters, and docs.
    enforce:
      - No Any/cast/type:ignore; ADTs over Optional; Result for errors; PEP 695 aliases only for concrete types.
      - Frozen dataclasses; exhaustive pattern matching with assert_never; explicit type narrowing.
      - Programs yield effect descriptions only; effects-as-data; interpreters/adapters own I/O and controlled mutation.
      - No for/while loops in pure layers except trampoline/program runner drivers; prefer comprehensions/match expressions.
      - check-code must pass (Black + mypy strict + doc links); coverage ≥ 45%; no skipped tests.
    suggest:
      - Replace Optional returns with ADT unions and pattern match results; refactor mutations to immutable updates.
      - Move side effects into interpreters; refactor loops to comprehensions or trampolines.

  - name: testing
    source: documents/engineering/testing.md
    intent: Testing finds problems; Docker-only execution with Result matchers and no skips.
    enforce:
      - Run pytest via Docker; capture full output to /tmp to avoid truncation.
      - Zero skipped tests; assertion present; cleanup fixtures before/after for stateful infra.
      - Use pytest-mock AsyncMock(spec=Protocol) for fakes; respect test pyramid.
    suggest:
      - Use effectful.testing matchers (assert_ok, assert_err, etc.) or exhaustive match.
      - Reject local pytest runs or truncated outputs.

  - name: docker_workflow
    source: documents/engineering/docker_workflow.md
    intent: All development in Docker; forbid host tooling and virtualenvs.
    enforce:
      - Commands prefixed with Docker/Poetry wrapper; no host poetry/pytest/mypy/pip/.venv.
      - Use named volumes; ensure services up for integration tests.
      - Agents must not perform git commit/push.
    suggest:
      - Provide docker-prefixed equivalents for any command; remove stray .venv.

  - name: development_workflow
    source: documents/engineering/development_workflow.md
    intent: Daily loop and procedures for new effects/domain models with user-owned commits.
    enforce:
      - Daily sequence: up containers → check-code → pytest inside Docker.
      - Follow 9-step effect and 5-step domain checklists; update unions/interpreters/docs.
      - Git commits/pushes only by user.
    suggest:
      - Add unit + integration tests for new effects; refresh docs/API/tutorials as needed.

  - name: command_reference
    source: documents/engineering/command_reference.md
    intent: Canonical commands and output-handling standards.
    enforce:
      - Use documented docker-prefixed commands for checks/tests/builds.
      - Capture test output to file to avoid truncation; analyze full logs.
    suggest:
      - Reference test stats context when estimating runtime; prefer tabled commands.

  - name: configuration
    source: documents/engineering/configuration.md
    intent: SSoT for env vars and compose services; highlight prod hardening.
    enforce:
      - Use documented env vars for Postgres/Redis/MinIO/Pulsar.
      - Compose services/volumes as specified; no config files outside env vars.
    suggest:
      - Remind on production requirements: TLS, secrets management, pooling, resource limits.

  - name: documentation_standards
    source: documents/documentation_standards.md
    intent: Enforce SSoT/DRY, naming, style, safe Mermaid subset, and type-safe examples.
    enforce:
      - SSoT markers; avoid duplication beyond brief summaries with links.
      - Naming: lowercase_with_underscores; imperative/active voice.
      - Mermaid safe subset: no dotted lines, subgraphs, or note-over; TB orientation when long.
      - Code examples follow zero escape-hatch policy.
    suggest:
      - Run tools/verify_links.py after refactors; use provided templates; prefer links over copies.

  - name: effect_patterns
    source: documents/engineering/effect_patterns.md
    intent: Promote generator DSL patterns, fail-fast handling, composition, metrics that don’t break business logic.
    enforce:
      - Use yield/yield from with type narrowing and exhaustive handling.
      - Do not ignore effect results; no direct infra calls.
      - Metrics errors must not fail business flow; handle ADTs explicitly.
    suggest:
      - Factor reusable sub-programs; pattern-match results; log metric failures without failing logic.

  - name: observability
    source: documents/engineering/observability.md
    intent: Metrics as pure effects with immutable registries; interpreter handles I/O; Prometheus/Grafana integration.
    enforce:
      - Registries are frozen; metric names/labels validated; interpreter performs recording.
      - Metric recording failures return ADTs; business logic should not fail on metrics errors.
    suggest:
      - Pre-register metrics; keep labels schema-aligned; keep metrics pure and typed.

  - name: monitoring_and_alerting
    source: documents/engineering/monitoring_and_alerting.md
    intent: Standardize metric naming/labels/cardinality and maintain actionable alert policy.
    enforce:
      - Metric names follow namespace_subsystem_metric_unit with units/_total; labels snake_case, bounded, and pre-registered; cardinality product < 10k.
      - Registries pre-register metrics; collectors validate names/labels/buckets; avoid dynamic names and ID/timestamp labels.
      - Alerts-as-code with severity-driven routing, runbook_url for critical/warning, and grouping/throttling configured.
    suggest:
      - Use framework default metrics; choose sensible histogram buckets; test PromQL expressions and runbook coverage in CI.

  - name: engineering_readme_meta
    source: documents/engineering/README.md
    intent: Maintain navigation, SSoT precedence, and core philosophy (“make invalid states unrepresentable”).
    enforce:
      - Quick navigation accuracy; SSoT documents override others; resolve conflicts per README guidance.
    suggest:
      - Update referenced-by lists and timestamps when standards change.

assembler:
  name: codex_assembler
  intent: Merge agent guidance into a single authoritative view while honoring SSoT precedence.
  process:
    - Collect all agent enforce/suggest items.
    - Resolve conflicts: engineering_readme_meta > specific SSoTs > navigation hubs.
    - Deduplicate overlapping global rules (e.g., Docker-only, zero escape hatches).
    - Emit final codex.yaml sections with globals, agents, and assembler notes.
  validation:
    - YAML must load (`python -c "import yaml; yaml.safe_load(open('codex.yaml'))"`).
    - All commands use docker-prefixed pattern; paths are repo-relative.
